### Contact Dependency Constraints

The dependency for a cell to be provided with some contacts on some membranes of a certain kind. The constraint must be checked at some points in time, also allowing for some points of time to be primordial.

### Blockage of contacts, membranes and cells.

The way that a cell prevents the entry of more data while it is busy with the current phase, solutions could include, border buffering, rejection of items. 

### Unification of Junction and Crumbs

It appears that there is a doubling of the asymettric call through exception handling, what is the most elegant expression of a response/failure, that will make sense to the AJAX world.  

### Priming
with the removal of induct, prime must optionally take the domain argument, that is to say here you will be operating. A cell may already have a membrane, that is populated and specific implemenations of prime might have an initial effect on the 

### Domains

Domains are the space within which 

### Asynchronous Prime and Dispose

these processes must be able to take place over some span of time, completing from a callback/event rather than in the execution frame that started the prime/dispose. The asynchrony comes from the preprime or postprime tractors or the preparation from the subconstructs.

### Child Dependency Constraints

Like contact dependency except specifically between the composite and subconstructs, unknown whether this will be through a contact that allows subconstructs to report operational status. It could be a requirement for a subcontact to expose a lifelink, allowing them to be destructed, and report their status. Alternatively the only requirements could be on a nominal, not a type level.

### Symmettirc links/contacts

Contacts media and mesh all must consider this case of a symmetric connection, ultimatley this results in peer relationships that are co calling, including couples and clusters.

### State Access Proxy

The exposed state is always operating through this proxy, the proxy allows for channelling of get/set, forbidding of write/read/extend/delete, the contact exposed can appear in whatever membranes as appropriate.

### Cell types
- Bare:  Everything left alone
- Synth: Everything accountable to the parent
- Weave: Everything connected by rule
- Room:  Everything aware of each other

### Membranes created by hook of contact
The rift is founded on the ability for a conduit contact to turn into a membrane. It is its way of injecting, therefore requiring the scope of injection to be widened to where it may designate a memebrane to target(providing the cell reather than the nucleus).

### Asynchronous link formation
Here we account for medium types that require the links to be created not instantaneously. That means their disruptive effects are active at the time of supposition but operational effects are not active until the connection can be made. Potentially this behaviour should be transposed onto the contacts participant in the connection, therefore not complicating this area of operation. For example if a link represents a server connection then really the contact on the server side will be emulated and return promises or exceptions until it is ready.

### Soft Reformation
Cells should be able to change their foundational composition, without causing chaos to ensue around them. The worst case is that the form change causes the contacts of the shell to be removed and all added, and all children to be disposed and reprimed. The best case is that contacts that are still there in either version are never removed and the children of the reformed cell are not disposed and reprimed. 

### Anonymous Composition
Considering both contacts and subconstructs. The ability to add without semanticising is vital to front end systems where the representation is visual-structural, therby designation would be by spacially targeted input actions. best guess is for automatic assignment of serial id's, the scope of which is uncertain.

### Contact Exclusivity constraints

Contact additions could occur from actions within context and cause failure because of it being a disallowed name collision(that could be participating in a live connection). 

Rule changes and also the initial configuration of rules can result in errors when the contacts targeted are claimed, gloved, or plugged. all hook actions should be sectionalisationss, that means there is no absolute covering, just isolating to a certain group. Those rule breaches are form failures that is critical to the cell health.

### Rules for Formation
hooks into the nucleus, sections forwarded to other membranes, and the creation of reaction. These should all be serail argument to a cell form construct. Extended cell forms would create the specific style of mesh.

### Sick State
software that is static can fail entirely when the smallest part has a failure, that isn't very natural, also there is a tendency to assume that the scope where the problem occurred must be discarded. Sickness makes failure into a state. That would allow for a 

Unfortunetely is requires all possible state transitions to be marked with events that are able to notify the relevant contexts of the new state. It also requires all current operational requirements/ contacts to respond with a particular kind of fail case. There is a huge amount of complexity contained within that. 

- cause
	- external operation failure
	- internal operation failure
	- constraint failure

